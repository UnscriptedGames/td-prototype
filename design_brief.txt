Tower Defence Prototype Design Brief

Overview
This document outlines the design for a modular, high-performance 2D tower defence game prototype built in Godot 4.4.x using GDScript. The project prioritises code reusability, memory management, and expandability, with placeholder assets and beginner-friendly systems.

1. Map with Single Enemy Path2D
- The main level uses multiple TileMapLayer nodes instead of a static Sprite2D background.
- TileMapLayers allow for painting objects that can be Y sorted and provide more flexible level design.
- Certain tiles have a custom data layer called 'buildable' to determine if a tower can be placed.
- The ghost tower checks if the tile it is above has the buildable property, removing the need for separate collision areas.
- While the ghost tower is active, buildable tiles are visually indicated (e.g., highlighted or outlined) so the player can see where towers can be placed.
- The ghost tower also changes colour depending on whether the location is valid or not.
- Level data is stored in a custom resource file, detailing wave count and enemy spawns.

2. Basic Tower Type
- Towers are Node2D scenes with a container for visuals (Node2D or Sprite2D).
- Range detection uses Area2D and CollisionShape2D (circle).
- The final, placed tower scene does not include buildable area detection.
- All placement logic (checking for buildable area and overlap) is handled by the ghost tower during placement, keeping the placed tower scene clean.
- Tower stats (fire rate, damage, projectile, etc.) are stored in a custom resource file.
- Building uses a ghost tower that follows the mouse, visually shows range, and indicates valid/invalid placement.
- Simple UI button for building towers (to be replaced by card system later).
- Clicking on a built tower visually indicates selection (e.g., outline or highlight), displays the tower's range indicator, and shows a Sell Tower button above the build button. Pressing Sell Tower removes the selected tower from the game.

3. Basic Enemy Type
- Enemies are Area2D scenes with AnimatedSprite2D and CollisionShape2D as children.
- Enemy stats (health, speed, reward, visuals, etc.) are stored in a custom resource file.
- Enemy movement is along a Path2D node in the level, using PathFollow2D for smooth path traversal.
- AnimatedSprite2D uses 2 directions: up-left and down-left. These animations are flipped for up-right and down-right as needed.
- Direction is calculated and mapped to the correct animation, with horizontal flipping as needed.
- Signals for death and reaching the end allow modular game logic.
- Pooling support: enemies reset state when reused.

4. Basic UI
- UI is a CanvasLayer scene with Label nodes for health, currency, and wave.
- UI updates via signals or a singleton managing game state.
- Placeholder fonts and visuals.

5. Placeholder Assets
- Simple shapes or basic sprites for all visuals.
- Assets organised in a clear folder structure (assets/sprites/, assets/sounds/, etc.).
- Subfolders for towers, enemies, UI, and effects.

6. Object Pooling
- Generic object pool system for enemies and projectiles.
- Pools created at game start; objects reused instead of instanced.
- Pooling logic ensures objects reset state on reuse.
- Designed for future expansion (e.g., effects, pickups).

7. Inheritance for Code Reusability
- Base classes for towers, enemies, and projectiles.
- Child classes override only necessary behaviour.
- Signals used for communication to reduce coupling.
- Code and resource files documented for clarity and future expansion.
- Performance and memory management prioritised in all systems.

Structured Approach
1. Set up project folder structure and placeholder assets.
2. Build the main map scene with Sprite2D background, Path2D, and YSort for accents.
3. Implement buildable area detection using Area2D/collision shapes.
4. Create base enemy and tower scenes, with resource files for stats.
5. Set up enemy movement along Path2D and direction-based animation logic.
6. Implement tower placement system with ghost tower and range visualisation.
7. Add basic UI for health, currency, and wave tracking.
8. Integrate object pooling for enemies and projectiles.
9. Ensure all systems use inheritance and signals for modularity.
10. Test and iterate on core gameplay; expand with stretch goals as needed.

Scene Structure
- Main scene: Node2D (root), Sprite2D (background), Path2D, YSort (accents), UI (CanvasLayer), buildable areas (Area2D).
- Enemy scene: Area2D, AnimatedSprite2D, CollisionShape2D.
- Tower scene: Node2D, Sprite2D container, Area2D (range), Area2D (buildable check).
- UI scene: CanvasLayer, Label nodes.

Notes
- All code will follow Godot 4.4.x and provided style guidelines.
- Placeholder assets will be replaced as development progresses.
- Stretch goals (card system, advanced towers/enemies, polish) will be addressed after the prototype is playable.

Game State Management
- Central game state (player health, currency, wave number, etc.) is managed by an Autoload singleton script called GameManager.
- GameManager emits signals (e.g., health_changed, currency_updated) for UI and other systems to listen and update accordingly.
- This pattern ensures robust, decoupled, and scalable game state management throughout the project.

Further Improvement Suggestions
- Use consistent, descriptive node names and scene structures for all major systems.
- Consider adding a dedicated HUD node under UI for all in-game overlays, making it easier to expand UI features later.
- Use custom Resource scripts and .tres files for level, tower, and enemy data to allow easy editing in the Godot inspector.
- Document all custom signals in scripts for clarity and maintainability.
- Add debug toggles and overlays (e.g., show collision shapes, print game state changes) to help during development.
- Organise assets by type and usage from the outset (e.g., assets/towers/, assets/enemies/, assets/ui/, assets/effects/, assets/sounds/, assets/backgrounds/).
- Place placeholder assets in their final intended folders for easy replacement.
- Leave comments or TODOs in the design brief and code for planned future features and stretch goals.
- Profile the game early using Godot's debugger and profiler tools, especially object pooling and signal usage, to catch any bottlenecks before adding complexity.
- Keep the design brief and code comments up to date as the project evolves.

Prototype Folder Structure
project-root/
|
├── Assets/      # Global assets reused across the game
│   ├── Audio/
│   ├── Fonts/
│   ├── Sprites/
│   ├── Textures/
│   └── Particles/
│
├── Config/      # Data assets for settings (.tres, .json), e.g. game balance, difficulty
│   ├── Levels/
│   ├── Towers/
│   ├── Enemies/
│   └── Waves/
│
├── Systems/     # Global logic, autoloads, and reusable gameplay systems
│   ├── GameManager/
│   ├── SceneManager/
│   └── GlobalSignals/
│
├── Entities/    # All towers, enemies, projectiles, and world objects
│   ├── Towers/
│   ├── Enemies/
│   └── Projectiles/
│
├── Levels/      # Game levels, scenes, and environmental assets
│   ├── MainLevel/
│   └── Tilesets/
│
├── UI/          # Menus, HUDs, and all user interface elements
│   ├── MainMenu/
│   ├── HUD/
│   └── Components/
│
├── Tests/       # Experimental scenes and prototypes
│   └── Prototypes/
│       ├── EnemyPathfinding.tscn
│       ├── TowerPlacement.tscn
│       └── UISystemTest.tscn

Stretch Goals
- Implement a card system for tower and enemy selection.
- Add advanced tower and enemy types with unique abilities.
- Create polished UI and UX elements, replacing all placeholder assets.
- Integrate audio effects and music.
- Develop a level editor and modding support.
- Optimise performance for target platforms.
- Expand documentation and tutorials for users and developers.

Prototype TODO List
1. (Complete) Set up the agreed folder structure in the project.
2. (Complete) Create placeholder assets and organise them in the correct folders.
3. Create base level template scene:
   - (Complete) Refactor main_map.tscn to base_level.tscn for use as a reusable level template.
   - (Complete) Add TileMapLayer(s) for the background and environment.
   - (Complete) Paint tiles and set up a custom 'buildable' data layer for tower placement.
   - (Complete) Add Path2D for enemy movement.
   - (Complete) Ensure no level-specific content is present in the base template.
   - (Complete) Move base_level.tscn to Levels/ or Levels/Templates/ as appropriate.
   - (Complete) Document workflow: create new levels by inheriting from base_level.tscn and adding unique content.
4. Implement buildable area visibility and ghost tower logic:
   - Highlight buildable tiles when placing towers.
   - Create ghost tower with range indicator and colour feedback.
   - Check for valid placement using the 'buildable' tile property and overlap.
5. Create base tower scene and data resource:
   - Add container for visuals.
   - Add Area2D for range detection.
   - Connect to projectile system.
   - Store tower stats in a resource file.
6. Create base enemy scene and data resource.
   - (Complete) Use Area2D as root.
   - (Complete) Add AnimatedSprite2D and CollisionShape2D.
   - (Complete) Add TextureProgressBar as health bar.
   - (Complete) Add exported variant array and random selection logic.
   - (Complete) Store enemy stats and variants in a resource file.
   - (Complete) Implement movement along Path2D.
   - (Complete) Add direction-based animation logic (up-left, down-left; flip for right).
   - (Complete) Implement robust end-of-path and death handling (single die animation, no double signal).
   - (Complete) Add _has_reached_end flag and prepare_for_new_path() for state management.
   - (Complete) Ensure pooling support: enemies reset state when reused.
   - (Complete) Prevent double emission of reached_end_of_path and double death logic.
7. (Complete) Create modular wave and spawn system.
   - (Complete) Design and implement SpawnInstruction resource for enemy spawns.
   - (Complete) Refactor WaveData resource to use array of SpawnInstruction resources.
   - (Complete) Add NodePath support for path selection in SpawnInstruction.
   - (Complete) Create and link SpawnInstruction resources for each enemy group.
   - (Complete) Create and configure WaveData resources for each wave.
   - (Complete) Remove old dictionary-based wave spawn system.
8. Implement object pooling for enemies and projectiles.
   - (Complete) Ensure all code changes follow GDScript style guide and modularity principles.
   - (Complete) Standardise use of a single EnemyData class for all enemy data resources.
   - (Complete) Remove duplicate/conflicting class_name EnemyData definitions.
   - (Complete) Clarify and fix .tres resource inheritance and script references.
   - (Complete) Diagnose and resolve Godot parser errors related to class naming and resource inheritance.
   - (Complete) Add/updated comments and structure for clarity and maintainability.
8. Build basic UI:
   - Add CanvasLayer and HUD elements (health, currency, wave).
   - Connect UI to GameManager signals.
9. Implement GameManager autoload for game state management.
10. Add tower selection and Sell Tower functionality:
    - Show range indicator and selection highlight.
    - Add Sell Tower button and removal logic.
11. Add test scenes in Tests/Prototypes for key systems (enemy pathfinding, tower placement, UI).
12. Profile performance and debug using Godot tools.
13. Update documentation and design brief as development progresses.
